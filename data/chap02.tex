% !TeX root = ../thuthesis-example.tex

\chapter{背景知识}

\section{社群发现}

社群发现（community detection）虽然没有严格的数学定义，但公认的做法是
将现实世界的社群建模成图(graph)结构，在图结构上进行社群发现。社群根据其属性
是否随时间变化可分为静态社群和动态社群，本文研究的是静态社群，它可以用
静态图来建模，以下简称图。
一个图结构$G$ 由节点集 $V$ 和边的集合 $E$ 组成，可记为 $G(V,E)$。
根据边是否有方向可将图分为有向图和无向图。无向图可以看成是每条边
有两个方向，从而针对有向图设计的社群发现算法也可以用到无向图上面来。
此外，根据边是否有权值可将图分为有权图和无权图。有权图中节点 $i$
和节点 $j$ 之间的权值可以用 $w_{ij}$ 表示。若有权图有方向，
则 $w_{ij}$ 可以不等于 $w_{ji}$。
无向图可以看成是每条边
的权值是1，从而针对有权图设计的社群发现算法也可以用到无权图上面来。

社群发现算法根据发现的社群是否重叠可分为两类，本文研究的是非重叠的
社群发现算法，即$V$可以分为互不重叠的若干子集。

不同的社群发现算法根据自己的标准寻找社群结构，这给一般意义上的比较造成了困难。
在本节中我们介绍的社群发现算法采用的标准叫做最小化平均误差。
这个概念最早是日本学者永野清仁于2010年提出\cite{mac}，但其数学形式早已有之。
在这里我们采用其最为广泛的形式，即针对带权的有向图的社群发现算法。
\begin{equation}\label{eq:IP}
  \lambda_1 := \min_{\P \in \Pi'}\frac{ f[\P] }{  \abs{\P} - 1 } 
\end{equation}
在式 \eqref{eq:IP} 中，
$\P$ 表示 $V$的一个分割， 也即  $P=\{C_1, \dots, C_k\}, \cup_{i=1}^k C_i=V$。
$\abs{\mathcal{P}}$ 表示集合 $\P$ 中元素的个数。
$\Pi$ 是 $V$ 上所有分割的集合而 $\Pi'=\Pi\backslash\{V\}$ 表示 $\Pi$
除去 $V$本身.
作用在$V$的子集$C$上的函数$f$
表示$C$和 $C$的补集 $V\backslash C$ 之间边的权值之和，即
$f(C)=\sum_{i \not\in C, j\in C, (i,j) \in E} w_{ij}$。
而作用在$V$的分割$\P$上的函数 $f[\P]$ 则是$f$分别作用$\P$中每一个元素之和。
即 $f[\P]=\sum_{C \in \P} f(C)$。有了如上的符号解释，
式 \eqref{eq:IP} 即不难理解，它表示各分割之间所有边的和对分割总数的平均值。

式 \eqref{eq:IP} 实际给出了一个社群发现的标准，对于扁平化的社群而言，
最小值$\lambda_1$ 对应的社群为
分割$\P^*$的子集。

下面介绍如何求解 $\lambda_1$ 及其对应的分割$\P^*$。永野清仁 \cite{mac} 的研究指出，
求解 \eqref{eq:IP} 等价于求解下面的组合优化问题
\begin{align}\label{eq:hlambda}
  h(\lambda) &= \min_{\P \in \Pi'} f[\P] - \abs{\P} \lambda 
  \end{align}
其中 $\lambda$ 是一个非负实数。
式 \eqref{eq:hlambda} 解的结构可以由一系列嵌套的分割
来描述，即存在正整数$k$，使得式 \eqref{eq:hlambda} 的解
为：
\begin{equation}\label{eq:PSP_structure}
  h(\lambda) = \begin{cases} h_{\P_0}(\lambda) & 0\leq \lambda < \lambda_1 \\
  h_{\P_i}(\lambda) & \lambda_i \leq \lambda < \lambda_{i+1} \textrm{ for } i = 1, \dots, k-1 \\
  h_{\P_k}(\lambda) & \lambda \geq \lambda_k
  \end{cases}
\end{equation}
在式 \eqref{eq:PSP_structure} 中，$\lambda_1, \dots, \lambda_{k-1},
\lambda_k$ 是递增的数列，而 $h_{\P}(\lambda)=f[\P]-|\P|\lambda$。
对于分割 $\P_0, \dots, \P_k$ 来说，
它们也有一个序关系。我们称分割 $P$ 是 $Q$ 的一个细分，
如果 $\forall C \in P, \exists C' \in Q, s.t. C\subset C'$，
并记为 $P \preceq Q$。基于细分的此种定义，我们有：
$\P_k \preceq \dots \preceq \P_1 \preceq \P_0$。
其中 $\P_0=\{V\}$ 而 $\P_k=\cup_{i=1}^n \{ i\}$。

在得到 $h(\lambda)$ 的表达式后，
我们指出 式 \eqref{eq:IP} 和
\eqref{eq:PSP_structure} 中的$\lambda_1$ 取值
相同，因此我们用了相同的符号。而 $\P^*=\P_1$。
从而式 \eqref{eq:IP}的解可以从式 \eqref{eq:PSP_structure}
的解中获得。

下面举一个简单的例子来解释上面的结论。
考虑一个带权的有向图$G(V,E)$，其结构
如图 \ref{fig:example_directed} 所示。
\begin{figure}
  \centering
  \begin{subfigure}[b]{0.5\linewidth}
  \includegraphics[width=\textwidth]{example_directed.pdf}
  \caption{一个有三个节点的带权有向图}
  \label{fig:example_directed}
  \end{subfigure}~
  \begin{subfigure}[b]{0.5\linewidth}
    \includegraphics[width=\textwidth]{dt.pdf}
    \caption{$h(\lambda)$ 的图像}
    \label{fig:dt}
    \end{subfigure}  
\end{figure}

因为
$G$ 包含的节点只有3个，可以使用枚举法计算对应的 $h(\lambda)$
函数，其函数图像如图 \ref{fig:dt} 所示。其中
$\P_0=\{ \{1,2,3\} \}, \P_1 = \{\{1,3\}, \{2\} \},
\P_2 =\{\{1\},\{2\},\{3\} \}$。
从图\ref{fig:dt} 中可以看到，在这个简单的例子中
$h(\lambda)$
是一个分段线性函数，对于一般的图$G$对应的
$h(\lambda)$ 也是如此。

因此，基于最小平均分割的方法，\ref{fig:example_directed}
中的图将被 划分成 $\P^*=\P_1$，即节点1和3被分成一类，
而节点2单独分成1类，这符合我们的直觉。

对于一般的图，其节点数目可能很多，此时用枚举法计算
$h(\lambda)$ 变得不可行。幸运的是，计算
$h(\lambda)$ 有多项式时间的算法。下面对\cite{mac}中描述的
方法进行介绍。我们把这一方法称为 PSP 算法
\footnote{该方法最早由
印度学者 纳拉亚南 在 1991 年提出 \cite{narayanan}
}，
其中
PSP 是 principal sequence of partition 的缩写，译为
主分割序列。
    
求解 \eqref{eq:PSP_structure} 只需得到在每一个
分界点处对应的 $\lambda$ 和 分割$\P$ 即可。
考虑到 $\P_k \preceq \dots \preceq \P_1 \preceq \P_0$
，
我们有 $|\P_0| \leq |\P_1| \dots \leq |\P_k|$，
即随着 $\lambda $ 的增大，线性函数的斜率逐渐增大。
这从图 \ref{fig:dt} 中也可以得到印证。
利用这一特点，我们基于分治的思想采用算法\ref{alg:psp}
获得分割序列。

\renewcommand{\algorithmicrequire}{\textbf{输入：}\unskip}
\renewcommand{\algorithmicensure}{\textbf{输出：}\unskip}

\begin{algorithm}
  \caption{求解主分割序列的算法 (PSP算法)}
  \label{alg:psp}
  \small
  \begin{algorithmic}[1]
    \REQUIRE 图$G$
    \ENSURE 序列 $L=[\lambda_1, \dots, \lambda_k]$
    和 $\mathcal{Q}=[\P_0, \dots, \P_k]$.
    \STATE \textbf{L}  $\leftarrow []$.
    \STATE $Q\leftarrow \{V\}, P \leftarrow \{ \{i \} | i \in V\}$
    \STATE $\mathbf{PSP}= [Q, P]$
    \STATE \texttt{Split}$(Q,P)$
    \STATE 对 $L$ 和 $\mathcal{Q}$
    按从小到大排序 \footnotemark
    \FUNCTION{\texttt{Split}$(Q,P)$}
     \STATE\label{alg:lambda} $\lambda' =
     {1 \over \abs{P} - \abs{Q}} (f(P)-f(Q))$
     \STATE\label{alg:lambda_plus} $h' = {1 \over \abs{P} - \abs{Q}}(\abs{P} f(Q) - \abs{Q} f(P))$
     \STATE\label{alg:lambda_f} $(\tilde{h}, P') = \texttt{DT}(G,\lambda')$
     \IF{$\tilde{h} = h'$}
       \STATE\label{algorithme:terminer} insert $\lambda'$ to $\mathbf{L}$
     \ELSE
       \STATE insert $P'$ to $\mathcal{Q}$
       \STATE\label{algorithme:gauche} \texttt{Split}$(Q, P')$
       \STATE\label{algorithme:droit} \texttt{Split}$(P',P)$
     \ENDIF
    \ENDFUNCTION
  \end{algorithmic}
\end{algorithm}
\footnotetext{$\mathcal{Q}$
中按集合的大小排序}

在算法\ref{alg:psp}第\ref{alg:lambda_f}行，
函数 \texttt{DT} 是用来求解 式\ref{eq:hlambda} 获得最优值
$\tilde{h}$ 和最优值对应的分割 $P'$。

在算法 \ref{alg:lambda}、\ref{alg:lambda_plus} 行，
求解 $(\lambda', h')$ 相当于在二维 $(\lambda, h)$
平面上计算直线
$h = f[P] - |P| \lambda $
和 $h = f[Q] - |Q| \lambda $ 的交点。假设 $P, Q$ 对应的
分界点分别是 $\lambda_P, \lambda_Q$（约定 $\{V\}$ 对应 0，
$\{\{i\}|i\in V\}$ 对应 $+\infty$），那么根据几何直观
$\lambda_Q \leq \lambda' \leq \lambda_P$。
紧接着，\ref{algorithme:gauche} 行的调用对应在
$[\lambda_Q, \lambda']$
区间范围内寻找剩余的分界点，而
\ref{algorithme:droit} 行的调用对应在
$[\lambda', \lambda_P]$
区间范围内寻找剩余的分界点。最后，
\ref{algorithme:terminer} 行表明
$[\lambda_Q, \lambda_P]$ 内没有分界点，无需再调用
\texttt{Split} 函数。

如前所述，函数 \texttt{DT}
（Dilworth truncation，迪尔沃思截断\footnote{采用迪尔沃思截断
这个名称是沿用了文献\cite{mac}}中的称谓）
是用于求解式\eqref{eq:hlambda}的算法，它实际上是一种贪心算法，
由算法\ref{alg:dt} 给出。

\begin{algorithm}
  \caption{迪尔沃思截断算法}\label{alg:dt}
  \begin{algorithmic}[1]
  \REQUIRE 图 $G$ 和 $\lambda$
  \ENSURE 分割 $\P$ 和 $h$
  \STATE
  $V^0 = \emptyset, x $ 是 $n$ 长的向量\footnotemark[1],
  $\mathcal{A} = \{\}$
  \FOR{$l=1, 2, \dots, n$}
  \STATE $V^l = \{l\} \cup V^{l-1}$
  \STATE\label{alg:tight} 计算 $x^* = \displaystyle\min_{ A: l \in A \subseteq V^l} f(A)- x(A)$。
   $T^l$ 是达到此最小值的集合，并且 $x_l \leftarrow x^* - \lambda$。 
    \STATE $U^l = T^l \cup [\cup \{A | A \in \mathcal{A}, A \cap T^l \neq \emptyset\}] $
  \STATE $\mathcal{A} = \{U^l\} \cup \{A | A \in \mathcal{A}, A \cap T^l = \emptyset \}$
  \ENDFOR
  \STATE $\P^* = \mathcal{A}, h_{\lambda} = x(V)$
  \end{algorithmic}
  \end{algorithm}
\footnotetext[1]{$n$ 是图$G$中节点的个数}

算法\ref{alg:dt}涉及到一种新的运算记号$x(A)$，
这里 $x$ 表示一个向量而 $A$ 是一个集合
$x(A)$ 定义为 $\sum_{i \in A} x_i$。